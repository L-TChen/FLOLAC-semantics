\title{Semantics of Functional Programming}
\subtitle{Lecture I: \PCF{} and its Operational Semantics}
\author[L.-T. Chen]{Chen, Liang-Ting\\
  \href{mailto:lxc@iis.sinica.edu.tw}{\texttt{lxc@iis.sinica.edu.tw}}}
\institute[IIS, Sinica]{Institute of Information Science, Academia Sinica}
\begin{document}
\frame{\maketitle}
\frame{\tableofcontents}
\section{Introduction: Why semantics matters?}  
\begin{frame}
  \frametitle{Outline}
\end{frame}
\begin{frame}
  \frametitle{Bug, bug, bug, everywhere!}
  \begin{enumerate}
    \item \textbf{Heartbleed}
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Language design}
  % C undefined behaviour
\end{frame}
\begin{frame}
  \frametitle{Verified software}
\end{frame}
\begin{frame}
  \frametitle{Common approaches}
  \begin{enumerate}
    \item \textbf{Operational approach}
    \item \textbf{Denotational approach}
    \item \textbf{Axiomatic approach}
  \end{enumerate}
\end{frame}
\subsection*{Reference}
\begin{frame}
  \frametitle{Reading Material}
  \emph{Denotational Semantics} and this lecture are based on the following 
  two books:
  \begin{enumerate}
    \item Thomas Streicher, \emph{Domain-Theoretic Foundations of Functional
      Programming}, World Scientific, 2006
    \item Robert Harper, \emph{Practical Foundations for Programming
        Languages}, Cambridge University Press, 2012
  \end{enumerate}
  Their preprints are available on the Internet.
\end{frame}
\section{Programming in PCF}
\subsection{Syntax and typing rules for PCF}
\begin{frame}
  \frametitle{What is PCF?}
  \PCF{} stands for \textbf{Programming Computable Functionals}, which is
  \begin{enumerate}
    \item an extension of simply typed lambda calculus with general recursion; 
    \item extremely simple compared to modern programming languages;
    \item Turing complete, i.e.\ every computable function on natural numbers
      can be defined in \PCF.
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Syntax of PCF}
  \begin{definition}
    The collection $\type$ of all types in \PCF{} is defined inductively:
    \[
      \tau \defeq \nat \mid \tau_1 \to \tau_2
    \]
  \end{definition}
  \begin{definition}
    The collection $\mathbf{Exp}$ of terms in \PCF{} is defined inductively:
    \begin{align*}
      \M & \defeq x \mid \zero \mid \suc\;\M \mid \ifz(\M, \M_0, x .\,\M_1) \\
      & \mid \lambda x .\, \M  \mid \M\;\N \mid \fix (x .\,\M)
    \end{align*}
    where $x$ is a variable. 
  \end{definition}
  The construct $\fix$ is called the \textbf{fixpoint operator}, or
  \textbf{general recursion}.
\end{frame}
\begin{frame}
  \frametitle{Typing Rules for PCF}
  Recall that a \textbf{judgement} $\Gamma \vdash \M : \tau$ denotes that $\M$
  has type $\tau$ under the context.
  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{}
      %\RightLabel{(Var)}
      \UnaryInfC{$\Gamma, x : \sigma, \Delta \vdash x : \sigma$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma, x : \sigma \vdash \M : \tau$}
      %\RightLabel{(Abs)}
      \UnaryInfC{$\Gamma \vdash \lambda x .\, \M : \sigma \to
        \tau$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \sigma \to \tau$}
      \AxiomC{$\Gamma \vdash \N : \sigma$}
      %\RightLabel{(App)}
      \BinaryInfC{$\Gamma \vdash \M\; \N : \tau$}
    \end{prooftree}

    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\Gamma \vdash \zero : \nat$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \nat$}
      \UnaryInfC{$\Gamma \vdash \suc\; \M : \nat$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma, x : \sigma \vdash \M : \sigma$}
      \UnaryInfC{$\Gamma\vdash \fix(x .\, \M) : \sigma$}
    \end{prooftree}
  \end{columns}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \nat$}
      \AxiomC{$\Gamma \vdash \M_0 : \tau$}
      \AxiomC{$\Gamma, x : \nat \vdash \M_1 : \tau $}
      \TrinaryInfC{$\Gamma \vdash \ifz(\M, \M_0, x .\, \M_1) : \tau$}
    \end{prooftree}
\end{frame}
\begin{frame}
  \frametitle{Examples: Predecessor}
  The predecessor of natural numbers can be defined as
  \[
    \pred \defeq \lambda x .\, \ifz (x, \zero, y .\, y)
    : \nat \to \nat
  \]
  with the following typing derivation:
  \begin{prooftree}
    \AxiomC{$\Gamma \vdash x : \nat$}
    \AxiomC{$\Gamma \vdash \zero : \nat$}
    \AxiomC{$\Gamma, y : \nat \vdash y : \nat$}
    \TrinaryInfC{$\Gamma \vdash \ifz (x, \zero, y .\, y) : \nat$}
    \UnaryInfC{$\vdash \lambda x .\, \ifz (x, \zero, y .\, y) : \nat\to\nat$}
  \end{prooftree}
  where $\Gamma \defeq x : \nat$. 
\end{frame}
\subsection{Operational semantics}
\begin{frame}
  \frametitle{Small-step reduction relation}
  \begin{definition}
    A \textbf{closed value}, denoted $\val$, in \PCF{} is one of the following:
    \begin{columns}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$\zero\;\,\val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\M \;\,\val$}
        \UnaryInfC{$\suc\; \M \;\,\val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$\lambda x .\,\M \;\, \val$}
      \end{prooftree}
    \end{columns}
  \end{definition}
%  For convenience, define $\underline{0} \defeq \zero$
%  and $\suc(\underline{n}) = \underline{n+1}$. 
  \begin{block}{Notation}
    The notation $\leadsto$ is a relation between terms, denoted
    \[
      \M \leadsto \M'
    \]
    which means that the term~$\M$ reduces to~$\M'$ in \emph{one step},
    and $\M \not\leadsto \M'$ means that there is no reduction from $\M$ to
    $\M'$.
  \end{block}
  For example, 
  \[
    \ifz(\zero, \M_0, x .\, \M_1) \leadsto \M_0
  \]
  means that $\ifz(\zero, \M_0, x.\, \M_1)$ reduces to $\M_0$.
\end{frame}
\begin{frame}
  \frametitle{Non-strict interpretation: call-by-name}
  Every argument is only evaluated if needed:
  \begin{columns}[t]
    \column[t]{.62\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\ifz(\M, \M_0, x .\,\M_1) \leadsto \ifz(\M', \M_0, x.\,\M_1)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\ifz(\zero, \M_0, x .\, \M_1) \leadsto \M_0$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\suc\;\M \;\, \val$}
      \UnaryInfC{$\ifz(\suc\;\M, \M_0, x .\, \M_1) \leadsto \M_1[\M/x]$}
    \end{prooftree}
    \column[t]{.38\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\M\;\N \leadsto \M'\;\N$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$(\lambda x .\, \M)\; \N \leadsto
        \M[\N/x] $}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\fix (x .\,\M) \leadsto \M[\fix (x .\, M)/x]$}
    \end{prooftree}
  \end{columns}
\end{frame}
\begin{frame}
  \frametitle{Strict interpretation: call-by-value}
  For the call-by-value evaluation strategy, every argument is evaluated
  before application:
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\suc\;\M \leadsto \suc\;\M'$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\M \;\,\val$}
      \AxiomC{$\N \leadsto \N'$}
      \BinaryInfC{$\M\; \N \leadsto \M'\; \N$}
    \end{prooftree}
    and modify the rule for application:
    \begin{prooftree}
      \AxiomC{$\N \;\,\val$}
      \UnaryInfC{$(\lambda x .\, \M)\; \N \leadsto
        \M[\N/x] $}
    \end{prooftree}
  In the following context, we adopt the call-by-name interpretation. 
\end{frame}
\begin{frame}
  \begin{definition}
    The relation $\leadsto^*$ between terms is defined inductively:\footnote{
      In short $\leadsto^*$ is the transitive reflexive closure of $\leadsto$.}
    \begin{columns}
      \column{.5\textwidth}
        \begin{prooftree}
          \AxiomC{}
          \UnaryInfC{$\M \leadsto^* \M$}
        \end{prooftree}
      \column{.5\textwidth}
        \begin{prooftree}
          \AxiomC{$\M \leadsto \M'$}
          \AxiomC{$\M' \leadsto^* \M''$}
          \BinaryInfC{$\M \leadsto^* \M''$}
        \end{prooftree}
    \end{columns}
  \end{definition}
  We say that a term $\M$ \emph{reduces to $\M'$ eventually} if $\M \leadsto^* \M'$. 
  \begin{theorem}
    For any two terms $\M$ and $\M'$, 
    $\M \leadsto^* \M'$ if and only if
    $\M' \equiv \M$ or there exists a finite sequence 
    \[
      \M \equiv \M_0 \leadsto \M_1 \leadsto \cdots \leadsto \M_k \equiv \M'. 
    \]
  \end{theorem}
\end{frame}
\begin{frame}
  \frametitle{In-class Exercise}
  Try to be familiar with $\ifz$.
  \begin{enumerate}
    \item Calculate $\pred\;\M$ for $\M \;\,\val$
      to closed values with their derivations: \\
      For the base case
      $\zero$:
      \[
        \pred\;\zero \leadsto^*\, ?
      \]
      For the inductive case $\M \equiv \suc\; \M$:
      \begin{prooftree}
        \AxiomC{$\suc\;M \;\,\val$}
        \UnaryInfC{$\pred\;(\suc\;\M) \leadsto^*\, ?$}
      \end{prooftree}
    \item Define $\mathtt{flip}\colon \nat \to \nat$
      such that $\mathtt{flip}\;\zero \leadsto^* \suc\; \zero$
      and $\mathtt{flip}\; (\suc \;\M) \leadsto^* \zero$. 
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Calculating the triangular numbers}
  We would like to define $\mathtt{sum}:\nat \to\nat$ such that 
  \[
    \mathtt{sum}\; n \leadsto^* \sum_{i = 0}^n i 
  \]
  by recursion:
  \begin{enumerate}
    \item $\mathtt{sum}\;\zero \leadsto^* \zero$; 
    \item $\mathtt{sum}\;(\suc\;\M) \leadsto^*
      \suc\; \M\mathbin{\mathtt{+}}\mathtt{sum}\;\M$
  \end{enumerate}
  where the definition of $\texttt{+}$ is left as an exercise.
  % some intro here
  \begin{equation}
    \label{eq:triangular_num}
    \fix(f .\, \lambda n .\, \ifz(n, \zero, m .\, n
    \mathbin{\texttt{+}} f\, m)\,) : \nat \to \nat
  \end{equation}
\end{frame}
\begin{frame}
  \frametitle{Comparison of natural numbers}
\end{frame}
\begin{frame}
  \frametitle{\texttt{fold} over natural numbers}
\end{frame}
\begin{frame}
  \frametitle{Determinacy}
  \begin{theorem}
    Suppose that
    $\M \leadsto \N_1$ and $\M \leadsto \N_2$. Then $\N_1 \equiv \N_2$. 
  \end{theorem}
  \begin{proof}
    Prove it by structural induction on $\M$. 
  \end{proof}
\end{frame}
\begin{frame}
  \frametitle{Big-step semantics}
  Instead of the small-step reduction relation~$\leadsto$, we can define a
  \textbf{big-step} reduction relation~$\Downarrow$
  between terms and \alert{closed values} as follows: 
\end{frame}
\begin{frame}
  \frametitle{Big-step semantics coincides with small-step semantics}
  \begin{theorem}
    For every closed term $\M$ and closed value~$\mathsf{V}$, 
    \[
      \M \Downarrow \V
      \qquad
      \text{if and only if}
      \qquad
      \M \leadsto^* \V. 
    \]
  \end{theorem}
\end{frame}
\section{Type safety}
\begin{frame}
  \frametitle{Inversion and substitution}
\end{frame}
\begin{frame}
\end{frame}
\begin{frame}
  \frametitle{Progress Theorem}
\end{frame}
\begin{frame}
  \frametitle{Preservation Theorem}
\end{frame}
\section{Equivalences}
\begin{frame}
\end{frame}
\section*{Exercises}
\begin{frame}<0>
  \begin{enumerate}
    \item Define the following programs in \PCF{}:
      \begin{enumerate}
        \item addition, subtraction, and multiplication. 
        \item factorials
        \item anything interesting? 
      \end{enumerate}
    \item Give the typing derivation of \eqref{eq:triangular_num}.
    \item Let $\bool$ be a type with two constructs $\false : \bool$
      and $\true : \bool$.
      \begin{enumerate}
        \item Provide the suitable typing rule for
          the \textbf{if-then-else} construct
          $\mathtt{if}$.
        \item Provide its small-step semantics.
      \end{enumerate}
    \item Compare the call-by-value and call-by-name interpretations. What
      rules are missing from the call-by-name interpretation?
    \item Primitive recursion, System T, totality. 
  \end{enumerate}
\end{frame}
\end{document}
