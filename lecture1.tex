\title[Operational Semantics]{Semantics of Functional Programming: PCF and its
Operational Semantics}
\author[L.-T. Chen]{Liang-Ting Chen}
\institute[IIS, Sinica]{Institute of Information Science, Academia Sinica}
\begin{document}
\frame{\maketitle}
\frame{\tableofcontents}
\section{Introduction: Why semantics matters?}  
\begin{frame}
  \frametitle{Outline}
\end{frame}
\begin{frame}
  \frametitle{Bug, bug, bug, everywhere!}
  \begin{enumerate}
    \item \textbf{Heartbleed}
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Language design}
  % C undefined behaviour
\end{frame}
\begin{frame}
  \frametitle{Verified software}
\end{frame}
\begin{frame}
  \frametitle{Common approaches}
  \begin{enumerate}
    \item \textbf{Operational approach}
    \item \textbf{Denotational approach}
    \item \textbf{Axiomatic approach}
  \end{enumerate}
\end{frame}
\subsection*{Reference}
\begin{frame}
  \frametitle{Reading Material}
  \emph{Denotational Semantics} and this lecture are based on the following 
  two books:
  \begin{enumerate}
    \item Thomas Streicher, \emph{Domain-Theoretic Foundations of Functional
      Programming}, World Scientific, 2006
    \item Robert Harper, \emph{Practical Foundations for Programming
        Languages}, Cambridge University Press, 2012
  \end{enumerate}
  Their preprints are available on the Internet. \\
\end{frame}
\begin{frame}
  \frametitle{Recommended Reference}
  \begin{enumerate}
    \item B.\ C.\ Pierce, \emph{Types and Programming Languages}, MIT Press,
      2002.
    \item S.~Abramsky and A.~Jung, Domain Theory. In
    \emph{Handbook of Logic in Computer
        Science}, vol.~3, p.p.\ 1--168. Clarendon Press, 1994.
  \end{enumerate}
\end{frame}
\section{Programming in PCF}
\subsection{Syntax and typing rules for PCF}
\begin{frame}
  \frametitle{What is PCF?}
  \texttt{PCF} stands for \textbf{Programming Computable Functionals}, which is
  \begin{enumerate}
    \item an extension of simply typed lambda calculus with a fixpoint
      operator~$\fix_\sigma$ for every type~$\sigma$; 
    \item extremely simple compared to modern programming languages;
    \item Turing complete, i.e.\ every computable function on natural numbers
      can be defined in \texttt{PCF}.
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Syntax of PCF}
  \begin{definition}
    The collection $\type$ of all types in PCF is defined inductively:
    \[
      \tau \defeq \nat \mid \tau_1 \to \tau_2
    \]
  \end{definition}
  \begin{definition}
    The collection $\mathbf{Exp}$ of terms in PCF is defined inductively:
    \begin{align*}
      \M \defeq x & \mid \zero \mid \suc(\M) \mid \ifz(\M, \M_0, x . \M_1) \\
      & \mid \lambda (x : \tau . \M) \mid \M (\N) \mid \fix_\sigma(x . \M)
    \end{align*}
    where $x$ is a variable, $\tau$ and $\sigma$ are types. 
  \end{definition}
  The construct $\fix$ is called the \textbf{fixpoint operator}, or
  \textbf{general recursion}.
\end{frame}
\begin{frame}
  \frametitle{Typing Rules for PCF}
  Recall that a \textbf{judgement} $\Gamma \vdash \M : \tau$ denotes that $\M$
  has type $\tau$ under the context.
  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{}
      %\RightLabel{(Var)}
      \UnaryInfC{$\Gamma, x : \sigma, \Delta \vdash x : \sigma$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma, x : \sigma \vdash \M : \tau$}
      %\RightLabel{(Abs)}
      \UnaryInfC{$\Gamma \vdash (\lambda x : \sigma\,.\, \M) : \sigma \to
        \tau$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \sigma \to \tau$}
      \AxiomC{$\Gamma \vdash \N : \sigma$}
      %\RightLabel{(App)}
      \BinaryInfC{$\Gamma \vdash \M\, (\N) : \tau$}
    \end{prooftree}

    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\Gamma \vdash \zero : \nat$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \nat$}
      \UnaryInfC{$\Gamma \vdash \suc (\M) : \nat$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\Gamma, x : \sigma \vdash \M : \sigma$}
      \UnaryInfC{$\Gamma\vdash \fix_\sigma(x . \M) : \sigma$}
    \end{prooftree}
  \end{columns}
    \begin{prooftree}
      \AxiomC{$\Gamma \vdash \M : \nat$}
      \AxiomC{$\Gamma \vdash \M_0 : \tau$}
      \AxiomC{$\Gamma, x : \nat \vdash \M_1 : \tau $}
      \TrinaryInfC{$\Gamma \vdash \ifz(\M, \M_0, x . \M_1) : \tau$}
    \end{prooftree}
\end{frame}
\begin{frame}
  \frametitle{Examples: Predecessor}
  The predecessor of natural numbers can be defined as
  \[
    \pred \defeq \lambda x . \nat . \ifz (x, \zero, y . y)
    : \nat \to \nat
  \]
  with the following typing derivation:
  \begin{prooftree}
    \AxiomC{$x : \nat \vdash x : \nat$}
    \AxiomC{$\vdash \zero : \nat$}
    \AxiomC{$y : \nat \vdash y : \nat$}
    \TrinaryInfC{$x : \nat \vdash \ifz (x, \zero, y . y) : \nat$}
    \UnaryInfC{$\vdash \lambda x : \nat . \ifz (x, \zero, y . y) : \nat\to\nat$}
  \end{prooftree}
\end{frame}
\subsection{Operational semantics}
\begin{frame}
  \frametitle{Small-step reduction relation}
  \begin{definition}
    A \textbf{closed value}, denoted $\val$, in PCF is one of the following:
    \begin{columns}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$\zero : \val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{$\M : \val$}
        \UnaryInfC{$\suc(\M) : \val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AxiomC{}
        \UnaryInfC{$(\lambda x : \tau . \M) : \val$}
      \end{prooftree}
    \end{columns}
  \end{definition}
%  For convenience, define $\underline{0} \defeq \zero$
%  and $\suc(\underline{n}) = \underline{n+1}$. 
  \begin{block}{Notation}
    The notation $\leadsto$ is a relation between terms, denoted
    \[
      \M \leadsto \M'
    \]
    which means that the term~$\M$ reduces to~$\M'$ in \emph{one step},
    and $\M \not\leadsto \M'$ means that there is no reduction from $\M$ to
    $\M'$.
  \end{block}
  For example, 
  \[
    \ifz(\zero, \M_0, x . \M_1) \leadsto \M_0
  \]
  means that $\ifz(\zero, \M_0, x. \M_1)$ reduces to $\M_0$.
\end{frame}
\begin{frame}
  \frametitle{Non-strict interpretation: call-by-name}
  A term can be applied even if it is not a closed value:
  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\ifz(\M, \M_0, x . \M_1) \leadsto \suc(\M', \M_0, \M_1)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\ifz(\zero, \M_0, x . \M_1) \leadsto \M_0$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\suc(\M) : \val$}
      \UnaryInfC{$\ifz(\suc(\M), \M_0, x . \M_1) \leadsto \M_1[\M/x]$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\M (\N) \leadsto \M' (\N)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$(\lambda x : \tau . \M) (\N) \leadsto
        \M[\N/x] $}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\fix_\sigma (x . \M) \leadsto \M[\fix_\sigma (x . M)/x]$}
    \end{prooftree}
  \end{columns}
\end{frame}
\begin{frame}
  \frametitle{Strict interpretation: call-by-value}
  Every application only happens if the input evaluates to a closed value:
  \begin{columns}[t]
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\suc(\M) \leadsto \suc(\M')$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\ifz(\M, \M_0, \M_1) \leadsto \suc(\M', \M_0, \M_1)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\ifz(\zero, \M_0, \M_1) \leadsto \M_0$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\suc(\M) : \val$}
      \UnaryInfC{$\ifz(\suc(\M), \M_0, x . \M_1) \leadsto \M_1[\M/x]$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AxiomC{$\M \leadsto \M'$}
      \UnaryInfC{$\M (\N) \leadsto \M' (\N)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\M : \val$}
      \AxiomC{$\N \leadsto \N'$}
      \BinaryInfC{$\M (\N) \leadsto \M' (\N)$}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{$\N : \val$}
      \UnaryInfC{$(\lambda x : \tau . \M) (\N) \leadsto
        \M[\N/x] $}
    \end{prooftree}
    \begin{prooftree}
      \AxiomC{}
      \UnaryInfC{$\fix_\sigma(x . \M) \leadsto
        \M[\fix_\sigma(x.\M) / x]$}
    \end{prooftree}
  \end{columns}
  In the following context, we adopt the call-by-name interpretation. 
\end{frame}
\begin{frame}
  \begin{definition}
    The relation $\leadsto^*$ between terms is defined inductively:\footnote{
      In short $\leadsto^*$ is the transitive reflexive closure of $\leadsto$.}
    \begin{columns}
      \column{.5\textwidth}
        \begin{prooftree}
          \AxiomC{}
          \UnaryInfC{$\M \leadsto^* \M$}
        \end{prooftree}
      \column{.5\textwidth}
        \begin{prooftree}
          \AxiomC{$\M \leadsto \M'$}
          \AxiomC{$\M' \leadsto^* \M''$}
          \BinaryInfC{$\M \leadsto^* \M''$}
        \end{prooftree}
    \end{columns}
  \end{definition}
  We say that a term $\M$ \emph{reduces to $\M'$ eventually} if $\M \leadsto^* \M'$. 
  \begin{theorem}
    For any two terms $\M$ and $\M'$, 
    $\M \leadsto^* \M'$ if and only if
    $\M' \equiv \M$ or there exists a finite sequence 
    \[
      \M \equiv \M_0 \leadsto \M_1 \leadsto \cdots \leadsto \M_k \equiv \M'. 
    \]
  \end{theorem}
\end{frame}
\begin{frame}
  \frametitle{In-class Exercise}
  Try to be familiar with $\ifz$.
  \begin{enumerate}
    \item Calculate $\pred(\M)$ for $\M : \val$
      to closed values with their derivations: \\
      For the base case
      $\zero$:
      \[
        \pred(\zero) \leadsto^*\, ?
      \]
      For the inductive case $\M \equiv \suc (\M)$:
      \begin{prooftree}
        \AxiomC{$\suc(M) : \val$}
        \UnaryInfC{$\pred(\suc(\M)) \leadsto^*\, ?$}
      \end{prooftree}
    \item Define $\mathtt{swap}\colon \nat \to \nat$
      such that $\mathtt{swap}(\zero) \leadsto^* \suc(\zero)$
      and $\mathtt{swap}(\suc(\M)) \leadsto^* \zero$. 
  \end{enumerate}
\end{frame}
\begin{frame}
  \frametitle{Calculating the triangular numbers}
  We would like to define $\mathtt{sum}:\nat \to\nat$ such that 
  \[
    \mathtt{sum}(n) \leadsto^* \mathtt{0 + 1 + \dots + n} 
  \]
  by recursion:
  \begin{enumerate}
    \item $\mathtt{sum}(\zero) \leadsto^* \zero$; 
    \item $\mathtt{sum}(\suc(\M)) \leadsto^* \suc(\M)\mathbin{\mathtt{+}}\mathtt{sum}(\M)$
  \end{enumerate}
  where the definition of $\texttt{+}$ is left as an exercise.
  % some intro here
  \begin{equation}
    \label{eq:triangular_num}
    \fix_{\nat \to \nat}(f . (\lambda n . \ifz(n, \zero, m . n
    \mathbin{\texttt{+}} f\, m)))
  \end{equation}
\end{frame}
\begin{frame}
  \frametitle{Comparison of natural numbers}
\end{frame}
\begin{frame}
  \frametitle{\texttt{fold} over natural numbers}
\end{frame}
\begin{frame}
  \frametitle{Determinacy}
  \begin{theorem}
    Suppose that
    $\M \leadsto \N_1$ and $\M \leadsto \N_2$. Then $\N_1 \equiv \N_2$. 
  \end{theorem}
  \begin{proof}
    Prove it by structural induction on $\M$. 
  \end{proof}
\end{frame}
\begin{frame}
  \frametitle{Big-step semantics}
  Instead of the small-step reduction relation~$\leadsto$, we can define a
  \textbf{big-step} reduction relation~$\Downarrow$
  between terms and \alert{closed values} as follows: 
\end{frame}
\begin{frame}
  \frametitle{Big-step semantics coincides with small-step semantics}
  \begin{theorem}
    For every closed term $\M$ and closed value~$\mathsf{V}$, 
    \[
      \M \Downarrow \mathsf{V}
      \quad
      \text{if and only if}
      \quad
      \M \leadsto^* \mathsf{V}. 
    \]
  \end{theorem}
\end{frame}
\section{Type safety}
\begin{frame}
\end{frame}
\subsection{Inversion and substitution}
\begin{frame}
\end{frame}
\subsection{Progress}
\begin{frame}
\end{frame}
\subsection{Preservation}
\begin{frame}
\end{frame}
\section{Equivalences}
\begin{frame}
\end{frame}
\section*{Exercises}
\begin{frame}<0>
  \begin{enumerate}
    \item Define the following programs in PCF:
      \begin{enumerate}
        \item addition, subtraction, and multiplication. 
        \item factorials
        \item anything interesting? 
      \end{enumerate}
    \item Give the typing derivation of \eqref{eq:triangular_num}.
    \item Let $\bool$ be a type with two constructs $\false : \bool$
      and $\true : \bool$.
      \begin{enumerate}
        \item Provide the suitable typing rule for
          the \textbf{if-then-else} construct
          $\mathtt{if}$.
        \item Provide its small-step semantics.
      \end{enumerate}
    \item Compare the call-by-value and call-by-name interpretations. What
      rules are missing from the call-by-name interpretation?
    \item Primitive recursion, System T, totality. 
  \end{enumerate}
\end{frame}
\end{document}
