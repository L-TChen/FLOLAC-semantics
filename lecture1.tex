\title{Semantics of Functional Programming}
\subtitle{Lecture I: \PCF{} and its Operational Semantics}
\author[L.-T. Chen]{Chen, Liang-Ting\\
  \href{mailto:lxc@iis.sinica.edu.tw}{\texttt{lxc@iis.sinica.edu.tw}}}
\institute[IIS, Sinica]{Institute of Information Science, Academia Sinica}
\begin{document}

\setcounter{framenumber}{-1}

\frame{\maketitle}
\section{Introduction}

\begin{frame}{The meaning of programs}
  How can we tell if a program is correct? 
  \begin{enumerate}
    \item The meaning of a program is ideally independent of its actual implementation.
    \item A rigorous specification of language is essential. Everything must be
      defined without any ambiguities. No undefined behaviour. 
    \item A structural approach to semantics. The meaning of a program is
      built from its parts, so verification is possible. 
    \item The precise definitions of notions, such as strict and lazy
      evaluation strategies. 
  \end{enumerate}
\end{frame}

\begin{frame}{Two approaches to be taught}
  \begin{enumerate}
    \item \textbf{Operational approach}: How values and functions are computed?
      E.g., for $\mathtt{add}:\nat \to \nat \to\nat$ and numerals
      $\underline{2}$, $\underline{4}$
      \begin{align*}
        & \mathtt{add}\;\underline{2}\;\underline{4}
        \leadsto \suc\;(\mathtt{add}\; \underline{1}\;\underline{4}) \\
        \leadsto{} & \suc\;\suc(\mathtt{add}\; \underline{0}\;\underline{4})
        \leadsto \suc\;\suc\;\underline{4} \equiv
        \underline{6}
      \end{align*}
    \item \textbf{Denotational approach}: What the values and functions are?
      The set $\mathbb{N}_\bot$ of natural numbers with
      \emph{divergence}~$\bot$ is the denotation of the type $\nat$, e.g., 
      \begin{align*}
        \sem{\mathtt{add}\;\underline{2}\;\underline{4}} 
        & = \sem{\mathtt{add}\;\underline{2}}\;\sem{\underline{4}} 
        = (\sem{\mathtt{add}}\;\sem{\underline{2}}) \;4  \\
        & = (x \mapsto 2 + x)\;4 
        = 2 + 4 = 6
      \end{align*}
      where $\sem{\mathtt{add}}\colon \mathbb{N}_\bot \to (\mathbb{N}_\bot \to
      \mathbb{N}_\bot)$. 
  \end{enumerate}
\end{frame}

\section{Programming in PCF}

\subsection{Syntax and typing rules for PCF}

\begin{frame}{What is PCF?}
  \PCF{} stands for \textbf{Programming Computable Functionals}, 
  \begin{enumerate}
    \item an extension of simply typed lambda calculus with $\nat$ and
      general recursion; 
    \item extremely simple compared to modern programming languages;
    \item Turing complete, i.e.\ every computable function on natural numbers
      can be defined in \PCF.
  \end{enumerate}
\end{frame}

\begin{frame}{Syntax of PCF}
  \begin{definition}
    Types in \PCF{} are defined by the inference rules
    \begin{columns}[t]
      \column{.5\textwidth}
      \begin{prooftree}
        \AXC{}
        \UIC{$\nat\;\,\type$}
      \end{prooftree}
      \column{.5\textwidth}
      \begin{prooftree}
        \AXC{$\tau_1\;\,\type$}
        \AXC{$\tau_2 \;\,\type$}
        \BIC{$\tau_1 \to \tau_2 \;\,\type$}
      \end{prooftree}
    \end{columns}
    or equivalently by the grammar $\tau \defeq \nat \mid \tau \to
    \tau$.
  \end{definition}
  \begin{definition}
    The collection of terms in \PCF{} is defined inductively:
    \begin{align*}
      \M \defeq{} & x \mid \lambda x .\, \M  \mid \M\;\N \mid \zero \mid \suc\;\M \\
     \mid{} & \ifz(\M; \M; x .\,\M) \mid \fix x .\,\M
    \end{align*}
    where $x$ is a variable. 
  \end{definition}
  The operator $\fix$ is called the \textbf{fixpoint operator}, or
  \textbf{general recursion}.
\end{frame}

\begin{frame}{Typing Rules for PCF}
  A \textbf{judgement} $\Gamma \vdash \M : \tau$ denotes that $\M$ has type
  $\tau$ under the context~$\Gamma$.  \PCF{} consists of
  \begin{itemize}
    \item simply typed lambda calculus (with $\to$ only):
    \begin{prooftree}
      \AXC{}
      \RightLabel{(var)}
      \UIC{$\Gamma, x : \sigma, \Delta \vdash x : \sigma$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\Gamma, x : \sigma \vdash \M : \tau$}
      \RightLabel{(abs)}
      \UIC{$\Gamma \vdash \lambda x .\, \M : \sigma \to
        \tau$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\Gamma \vdash \M : \sigma \to \tau$}
      \AXC{$\Gamma \vdash \N : \sigma$}
      \RightLabel{(app)}
      \BIC{$\Gamma \vdash \M\; \N : \tau$}
    \end{prooftree}
  \item the type of natural numbers:
    \begin{prooftree}
      \AXC{}
      \RightLabel{(z)}
      \UIC{$\Gamma \vdash \zero : \nat$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\Gamma \vdash \M : \nat$}
      \RightLabel{(s)}
      \UIC{$\Gamma \vdash \suc\; \M : \nat$}
    \end{prooftree}
  \end{itemize}
\end{frame}

\begin{frame}
  \begin{itemize}
    \item \textbf{if zero} test: it is meant to be the \emph{case analysis}
      on natural numbers:
      \small
      \begin{prooftree}
        \AXC{$\Gamma \vdash \M : \nat$}
        \AXC{$\Gamma \vdash \M_0 : \tau$}
        \AXC{$\Gamma, x : \nat \vdash \M_1 : \tau $}
        \RightLabel{(ifz)}
        \insertBetweenHyps{\hskip .1em}
        \TIC{$\Gamma \vdash \ifz(\M; \M_0; x .\, \M_1) : \tau$}
      \end{prooftree}
    \item \textbf{general recursion} (to be explained):
      \begin{prooftree}
        \AXC{$\Gamma, x : \sigma \vdash \M : \sigma$}
        \RightLabel{(Y)}
        \UIC{$\Gamma\vdash \fix x .\, \M : \sigma$}
      \end{prooftree}
     \normalsize
  \end{itemize}
  \begin{definition}
    A term~$\M$ of type $\tau$ is called a \textbf{program}
    of type $\tau$ in \PCF{} if it is derivable under an empty context, i.e.\ 
    the judgement
    \[
      () \vdash \M : \tau
    \] 
    is derivable where $()$ denotes the empty context for emphasis. 
  \end{definition}
  E.g.\ $\fix x .\, \suc\; x$ and $\ifz(\zero; \lambda
  x.\,\zero; y.\, \lambda z.\, y)$ are programs, but~$\lambda y.\, x\; y$
  or $\suc\; (\lambda x .\, \suc\; x)$ are not.
\end{frame}

\begin{frame}{Example: Predecessor}
  The predecessor of natural numbers can be defined as
  \[
    \pred \defeq \lambda x .\, \ifz (x; \zero; y .\, y)
    : \nat \to \nat
  \]
  with the following typing derivation:
  \begin{prooftree}
    \AXC{}
    \UIC{$\Gamma \vdash x : \nat$}
    \AXC{}
    \UIC{$\Gamma \vdash \zero : \nat$}
    \AXC{}
    \UIC{$\Gamma, y : \nat \vdash y : \nat$}
    \insertBetweenHyps{\hskip .5em}
    \TIC{$\Gamma \vdash \ifz (x; \zero; y .\, y) : \nat$}
    \UIC{$\vdash \lambda x .\, \ifz (x; \zero; y .\, y) : \nat\to\nat$}
  \end{prooftree}
  where $\Gamma \defeq x : \nat$. 
\end{frame}

\subsection{Operational semantics}

\begin{frame}{One-step reduction}
  \begin{definition}
    A \textbf{closed value} denoted $\val$ is one of the following:
    \begin{columns}
      \column{.3\textwidth}
      \begin{prooftree}
        \AXC{}
        \UIC{$\zero\;\,\val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AXC{$\M \;\,\val$}
        \UIC{$\suc\; \M \;\,\val$}
      \end{prooftree}
      \column{.3\textwidth}
      \begin{prooftree}
        \AXC{}
        \UIC{$\lambda x .\,\M \;\, \val$}
      \end{prooftree}
    \end{columns}
  \end{definition}
  A value is meant to be the final result of computation. For example, 
  natural numbers $\zero, \suc\; \zero$ and lambda functions $\lambda x.\, x$
  etc. This formulation also includes ill-typed terms such as $\suc\; (\lambda
  x.\, \M)$.
  \begin{block}{Notation}
    The notation $\leadsto$ is a relation between terms, denoted
    \[
      \M \leadsto \M'
    \]
    which means that the term~$\M$ reduces to~$\M'$ in \emph{one step}.
  \end{block}
\end{frame}

\begin{frame}{Reduction of general recursion and natural numbers}
  For general recursion, each occurrence of $\fix.\,\M$ reduces to an substitution
  of~$x$ in~$\M$ by itself:
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\leadsto$-fix)}
      \UIC{$\fix x .\,\M \leadsto \M[\fix x .\, M/x]$}
    \end{prooftree}

  For the \emph{eager evaluation},  $\suc\;\M$ reduces to $\suc\;\M'$ if $\M$
  reduces to $\M'$
    \begin{prooftree}
      \AXC{$\M \leadsto \M'$}
      \RightLabel{($\leadsto$-$\suc$)}
      \UIC{$\suc\;\M \leadsto \suc\;\M'$}
    \end{prooftree}
  On the other hand, it is possible to defer the evaluation of natural numbers,
  and this evaluation is known as the \emph{lazy evaluation}. 
  To do so, we simply remove this reduction rule $\leadsto$-$\suc$
  and modify the definition of closed values for $\suc$ to
  \begin{prooftree}
    \AXC{}
    \UIC{$\suc\; \M\;\,\val$}
  \end{prooftree}
  without any assumptions. 
\end{frame}

\begin{frame}{Reduction of $\ifz$}
  For the if-zero test,  the first argument must be reduced to a closed
  value before branching, but branching can be done before the evaluation
  on branches:
    \begin{prooftree}
      \AXC{$\M \leadsto \M'$}
      \RightLabel{($\leadsto$-$\ifz$)}
      \UIC{$\ifz(\M; \M_0; x .\,\M_1) \leadsto \ifz(\M'; \M_0; x.\,\M_1)$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\leadsto$-$\ifz_0$)}
      \UIC{$\ifz(\zero; \M_0; x .\, \M_1) \leadsto \M_0$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\suc\;\M \;\, \val$}
      \RightLabel{($\leadsto$-$\ifz_1$)}
      \UIC{$\ifz(\suc\;\M; \M_0; x .\, \M_1) \leadsto
        \M_1[\M/x]$}
    \end{prooftree}
\end{frame}

\begin{frame}{Reduction for application: call-by-name and call-by-value}
  In call-by-name evaluation, arguments are substituted directly into the
  function body. It is a \alert{non-strict} evaluation strategy, because
  application with non-terminating arguments can be terminating.
    \begin{prooftree}
      \AXC{$\M \leadsto \M'$}
      \RightLabel{($\leadsto$-lapp)}
      \UIC{$\M\;\N \leadsto \M'\;\N$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\leadsto$-by-name)}
      \UIC{$(\lambda x .\, \M)\; \N \leadsto
        \M[\N/x] $}
    \end{prooftree}
  In call-by-value evaluation, each argument is evaluated
  before application, so we replace ($\leadsto$-by-name) by the following two
  rules. It is a \alert{strict} evaluation strategy, as
  non-terminating arguments always lead to non-terminating terms. 
    \begin{prooftree}
      \AXC{$\M \;\,\val$}
      \AXC{$\N \leadsto \N'$}
      \RightLabel{($\leadsto$-by-value-$1$)}
      \BIC{$\M\; \N \leadsto \M'\; \N$}
    \end{prooftree}
    \begin{prooftree}
      \AXC{$\N \;\,\val$}
      \RightLabel{($\leadsto$-by-value-$2$)}
      \UIC{$(\lambda x .\, \M)\; \N \leadsto
        \M[\N/x] $}
    \end{prooftree}
  In the following context, we adopt the \emph{call-by-name} interpretation. 
\end{frame}

\begin{frame}{Many-step reduction}
  \begin{definition}
    The relation $\leadsto^*$ between terms is defined inductively:
    \begin{columns}
      \column{.5\textwidth}
        \begin{prooftree}
          \AXC{}
          \UIC{$\M \leadsto^* \M$}
        \end{prooftree}
      \column{.5\textwidth}
        \begin{prooftree}
          \AXC{$\M_1 \leadsto \M_2$}
          \AXC{$\M_2 \leadsto^* \M_3$}
          \insertBetweenHyps{\hskip .5em}
          \BIC{$\M_1 \leadsto^* \M_3$}
        \end{prooftree}
    \end{columns}
  \end{definition}
  Note that $M \leadsto^* \M'$ if $\M'$ is reachable from $\M$ after finitely
  many steps of reduction, i.e.\ $\M = \M_0 \leadsto \M_1 \leadsto \cdots \M_k
  = \M'$. 
  \begin{proposition}
    The relation $\leadsto^*$ is reflexive and transitive. 
  \end{proposition}
  \begin{proof}
    Easy exercise. 
  \end{proof}
\end{frame}


\begin{frame}{Example: Calculating the factorials}
  To define the factorials, we are seeking for a function~$\mathtt{fact}$ satisfying
  \[
    \mathtt{fact}\colon n \mapsto
    \begin{cases}
      0 & \text{if } n = 1 \\
      n \times \mathtt{fact}(n') & \text{if } n = n' + 1
    \end{cases}
  \]
  and this can be understood as a fixpoint of the functional~$F$ mapping~$f
  \colon\mathbb{N} \to \mathbb{N}$ to~$f'\colon\mathbb{N}\to\mathbb{N}$ defined
  by
  \[
    \label{eq:factorial_informal}
    f'\colon n \mapsto
    \begin{cases}
      1 & \text{if } n = 0 \\
      n \times f(n') & \text{if } n = n' + 1
    \end{cases}
  \]
  where $f'$ does not depend on itself.
\end{frame}

\begin{frame}
  Under the context of $\Gamma \defeq f\colon \nat \to \nat$, we
  define a function depending on $f$ as follows:
  \[
    \Gamma \vdash \lambda n.\, \ifz(n; \suc\;\zero; m.\, n \times (f\; m))
      : \nat \to \nat
  \]
  and thus we derive its fixpoint by $\fix$:
  \[
    \mathtt{fact} \defeq
    \fix f.\, \lambda n .\, \ifz(n; \suc\;\zero; m .\, n\times (f\; m))
  \]
  where the term $\suc\;\zero$ represents the natural number $1$. 
  \begin{example}
    Let $\underline{0} \defeq \zero$ and $\underline{n+1} \defeq
    \suc\;\underline{n}$. 
    We calculate $\mathtt{fact}\;\underline{2}$:

    \begin{align*}
      \mathtt{fact}\;\underline{2} & \leadsto 
      (\lambda n.\, \ifz(n; \underline{1}; m .\, n \times (\mathtt{fact}\; m)))\;
      \underline{2} \\
      & \leadsto \ifz(\underline{2}; \underline{1}; m .\, \underline{2}
      \times (\mathtt{fact}\; m))
      \\
      & \leadsto \underline{2} \times (\mathtt{fact}\; \underline{1}) \\
      & \leadsto \underline{2} \times (\lambda n.\, \ifz(n; \underline{1}; m.\,
      n \times (\mathtt{fact}\; m))\; \underline{1}) \\
      & \leadsto \cdots \leadsto \underline{2}
      \times (\underline{1} \times \underline{1}) \leadsto^* \underline{2}
    \end{align*}
    where the definition of $\times : \nat \to \nat \to nat$ is left as an
    exercise. 
  \end{example}
\end{frame}
\begin{frame}{In-class exercise}
  Try to be familiar with $\ifz$.
  \begin{enumerate}
    \item Calculate $\pred\;\M$ for $\M \;\,\val$
      to closed values with their derivations: \\
      For the base case
      $\zero$:
      \[
        \pred\;\zero \leadsto^*\, ?
      \]
      For the inductive case $\M = \suc\; \N$:
      \begin{prooftree}
        \AXC{$\suc\;\N \;\,\val$}
        \UIC{$\pred\;(\suc\;\N) \leadsto^*\, ?$}
      \end{prooftree}
    \item Define $\mathtt{flip}\colon \nat \to \nat$
      such that $\mathtt{flip}\;\zero \leadsto^* \suc\; \zero$
      and $\mathtt{flip}\; (\suc \;\M) \leadsto^* \zero$. 
  \end{enumerate}
\end{frame}

\begin{frame}[fragile]{In-class exercise: \texttt{fold} on natural numbers}
  \texttt{fold} on natural numbers is defined in Haskell as follows:
  \begin{verbatim}
    fold :: (a -> a) -> a -> Integer -> a
    fold f e 0 = e
    fold f e n = f (fold f e (n - 1))
  \end{verbatim}
  By modifying the definition of $\mathtt{fact}$, give the corresponding
  term of $\mathtt{fold}$ in \PCF{}. 
\end{frame}


\section{Type safety}

\begin{frame}{Progress Theorem}
  Every well-typed is either a closed value or a reducible term. 
  \begin{theorem}
    If ${} \vdash \M : \tau$ then either $\M$ is a closed value or
    there exists $\M'$ such that $\M \leadsto \M'$. 
  \end{theorem}
  \begin{proof}
    By induction on the derivation of ${}\vdash \M:\tau$. For the case that
    \begin{prooftree}
      \AXC{$\M : \nat$}
      \UIC{$\vdash \suc\; \M : \nat$}
    \end{prooftree}
    $\M$ is either a closed value or a reducible term by induction hypothesis:
    \begin{enumerate}
      \item If $\M$ is a closed value, then $\suc\; \M$ is also a closed value
        by definition. 
      \item Suppose that $\M \leadsto \M'$ for some $\M'$. Then, by the rule
        ($\leadsto$-$\suc$), we also have $\suc\;\M \leadsto \suc\;\M'$. 
    \end{enumerate}
  \end{proof}
\end{frame}

\begin{frame}{Proofs are programs}
  \begin{remark}
    Note that given a program $\M : \tau$, the previous proof produces either a
    closed value or a \PCF{} term $\M'$ with a proof that $\M$ reduces to $\M'$.
    Forgetting the proof, the proof itself is indeed a program
    which asks a \PCF{} term, preforms a single reduction and return a term
    tagged either \texttt{done} or \texttt{not yet}. 
  \end{remark}
\end{frame}
\begin{frame}{Substitution Lemma}
  If a variable~$x : \tau$ in a term~$\M$ is substituted by another term~$\N$
  of the same type, then the type of the resulting term remains. 
  \begin{lemma}
    If $\Gamma, x : \sigma \vdash \M : \tau$ and $\Gamma \vdash \N : \sigma$,
    then $\Gamma \vdash \M[\N/x] : \tau$. 
  \end{lemma}
  \begin{proof}
    Induction on the derivation of $\Gamma, x : \sigma \vdash \M : \tau$.
    Suppose that $\Gamma, x : \sigma \vdash \M : \tau$ is derived from
    \begin{prooftree}
      \AXC{}
      \RightLabel{(var)}
      \UIC{$\Delta, y : \tau, x : \sigma \vdash y : \tau$}
    \end{prooftree}
    that is, $\Gamma = \Delta, y : \tau$ and $\M = y$ for some variable $y$.
    Then, we need to show that $\Delta, y : \tau \vdash y[\N/x] : \tau$.
    \begin{enumerate}
      \item If $x = y$, then $y[\N/x] = \N : \sigma$ and $\sigma = \tau$.
      \item Otherwise, $x \neq y$, then $y[\N/x] = y : \tau$. 
    \end{enumerate}
    Other cases follow similarly.
  \end{proof}
\end{frame}

\begin{frame}{Preservation Theorem}
  The one-step evaluation preserves types. This
  property is also called \textbf{Subject Reduction}.
  \begin{theorem}
    If ${}\vdash \M : \tau$ and $\M \leadsto \N$ then ${}\vdash \N : \tau$. 
  \end{theorem}
  \begin{proof}
    We prove it by induction on the derivation of ${}\vdash \M : \tau$ and $\M
    \leadsto \M'$.
    For the case that
    \begin{prooftree}
      \AXC{$ x : \sigma \vdash \M : \sigma$}
      \UIC{$\vdash \fix x.\, \M : \sigma$}
    \end{prooftree}
    we do induction on $\leadsto$, but there is exactly one rule applicable:
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\leadsto$-fix)}
      \UIC{$\fix x.\,\M \leadsto \M[\fix x.\,\M/x]$}
    \end{prooftree}
    By Substitution Lemma, it follows that $\vdash M[\fix x.\, M/x] : \sigma$,
    and other cases follow similarly. 
  \end{proof}
\end{frame}

\section{Big-step semantics}

\begin{frame}{Call-by-name big-step semantics}
  Instead of the one-step reduction relation~$\leadsto$, we turn to the
  \textbf{big-step} reduction relation~$\Downarrow$, formulating
  the notion that a term $\M$ reduce to its final value~$\V$. 
    \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\Downarrow$-zero)}
      \UIC{$\zero \Downarrow \zero$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$\M \Downarrow \underline{n}$}
      \RightLabel{($\Downarrow$-suc)}
      \UIC{$\suc\;\M \Downarrow \suc\;\underline{n}$}
    \end{prooftree}
  \end{columns}

  \begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{}
      \RightLabel{($\Downarrow$-lam)}
      \UIC{$\lambda x.\, \M \Downarrow \lambda x.\, \M$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$\M\Downarrow \lambda x.\, \mathsf{E}$}
      \AXC{$\mathsf{E}[\N/x] \Downarrow \V$}
      \RightLabel{($\Downarrow$-app)}
      \BIC{$\M\;\N \Downarrow \V$}
    \end{prooftree}
  \end{columns}

\begin{columns}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$\M\Downarrow \zero$}
      \AXC{$\M_0\Downarrow \V$}
      \RightLabel{($\Downarrow$-$\ifz_0$)}
      \BIC{$\ifz(\M; \M_0; x.\, \M_1) \Downarrow \V$}
    \end{prooftree}
    \column{.5\textwidth}
    \begin{prooftree}
      \AXC{$\M\Downarrow \suc\;\underline{n}$}
      \AXC{$\M_1[\underline{n}/x] \Downarrow \V$}
      \RightLabel{($\Downarrow$-$\ifz_1$)}
      \BIC{$\ifz(\M; \M_0; x.\, \M_1) \Downarrow \V$}
    \end{prooftree}
\end{columns}

    \begin{prooftree}
      \AXC{$\M[\fix x.\, \M/ x] \Downarrow \V$}
      \RightLabel{($\Downarrow$-fix)}
      \UIC{$\fix x.\, \M \Downarrow \V$}
    \end{prooftree}
\end{frame}

\begin{frame}{Closed values}
  We shell justify the intended meaning: whenever $\M \Downarrow \V$, the term $\V$
  is always a closed value:
  \begin{lemma}
    For every terms $\M$ and $\V$, the term $\V$ is a closed value if $\M
    \Downarrow \V$. 
  \end{lemma}
  \begin{proof}
    By induction on the formulation of $\M \Downarrow \V$. 
  \end{proof}
  Moreover, a closed value reduces to itself:
  \begin{lemma}
    If $\V$ is a closed value, then $\V\Downarrow\V$. 
  \end{lemma}
  \begin{proof}
    By structural induction on $\V\;\,\val$. That is, it is sufficient to check
    that $\zero \Downarrow \zero$, $\lambda x.\, \M \Downarrow \lambda x.\,
    \M$; $\suc\;\M \Downarrow \suc\;\M$ if $\M \Downarrow \M$ by induction
   hypothesis.  
  \end{proof}
\end{frame}

\begin{frame}{Agreement of big-step and one-step semantics}
  Indeed, the big-step reduction can be characterised with respect to the
  one-step step reduction as follows:
  \begin{theorem}
    For every term $\M$ and $\V$, $\M \Downarrow \V$ if and only if $ \M \leadsto^* \V$
    with $\V \;\, \val$. 
  \end{theorem}

  \begin{block}{Proof Sketch.}
    \begin{enumerate}
      \item First we show that if $\M\Downarrow \V$ then $\M \leadsto^* \V$
        by induction on~$\Downarrow$ and~$\leadsto^*$. 
      \item Second, by induction on~$\leadsto$ and $\Downarrow$  we show that
        \begin{prooftree}
          \AXC{$\M \leadsto \N \Downarrow \V$}
          \UIC{$\M\Downarrow \V$}
        \end{prooftree}
      \item Finally,  by induction on~$\leadsto^*$ we show that
        \begin{prooftree}
          \AXC{$\M \leadsto^*   \N \Downarrow \V$}
          \UIC{$\M\Downarrow \V$}
        \end{prooftree}
        
    \end{enumerate}
    In particular, for every $\M \leadsto^* \V$ with $\V\;\,\val$,
    we always have $\V\Downarrow \V$, so it follows $\M\Downarrow \V$.
  \end{block}
\end{frame}

\begin{frame}
\begin{proof}
  \begin{enumerate}
    \item We show the case ($\Downarrow$-fix), which is similar to other
      cases:
      \begin{prooftree}
        \AXC{}
        \UIC{$\fix x.\, \M \leadsto \M[\fix x.\, \M/x]$}
        \AXC{}
        \UIC{$M[\fix x.\, \M / x] \leadsto^* \V$}
        \BIC{$\fix x.\, \M \leadsto* \V$}
      \end{prooftree}
      and by assumption $V$ has no further reduction. 
    \item We show the case ($\leadsto$-fix), which is similar to other cases.
      By hypothesis, we have $\fix x.\, \M \leadsto \M[\fix x.\, \M/x]$.
      If $\M[\fix x.\, \M/ x] \Downarrow \V$,
      then by ($\Downarrow$-fix) it follows that $\fix
      x.\,\M\Downarrow\V$. 
    \item Induction on $\leadsto^*$. 
  \end{enumerate}
\end{proof}
By the agreement of big-step and one-step semantics, we easily conclude
that the Subject Reduction also holds for big-step semantics:
\begin{corollary}
  If ${}\vdash \M : \tau$ and $\M \Downarrow \V$ then ${}\vdash \V : \tau$.
\end{corollary}
\end{frame}

\section*{Exercises}

\begin{frame}<0>{Basic}
  \begin{enumerate}
    \item Define the following programs in \PCF{}.
      \begin{enumerate}
        \item Multiplication of natural numbers
          \emph{Hint.} Define addition first;
        \item Fibonacci numbers; 
        \item Parity test, i.e.\ a function determines whether the given
          argument is an odd or even number. Return $\zero$ if even,
          $\suc\;\zero$ otherwise. 
      \end{enumerate}
    \item \seti Let $\bool$ be a type with two constructors:
      \begin{columns}
        \column{.5\textwidth}
        \begin{prooftree}
          \AXC{}
          \UIC{$\true:\bool$}
        \end{prooftree}
        \column{.5\textwidth}
        \begin{prooftree}
          \AXC{}
          \UIC{$\false:\bool$}
        \end{prooftree}
      \end{columns}
      \begin{enumerate}
        \item Provide the typing rule for
          the conditional construct $\mathtt{if}$:
          \begin{prooftree}
            \AXC{?}
            \UIC{$\Gamma \vdash \mathtt{if}(\M_0; \M_1; \M_2):\tau$}
          \end{prooftree}
        \item Provide its one-step semantics.
      \end{enumerate}
  \end{enumerate}
\end{frame}

\begin{frame}<0>{Advanced}
  \begin{enumerate}
    \conti
    \item 
      Define primitive recursion in \PCF{}
      \[
        \mathtt{rec} : \tau\to(\nat\to\tau\to\tau)\to\nat\to\tau
      \]
      such that it reduces to 
      \begin{align*}
        & \mathtt{rec}\;e_0\; f\; \zero && \leadsto^* e_0 \\
        & \mathtt{rec}\;e_0\; f\; (\suc\;\M) && \leadsto^*
        f\;\M \;(\mathtt{rec}\;e_0\; f\; \M)
      \end{align*}
      respectively 
    \item \seti
      Show that $\mathtt{rec}\;e_0\;f\;\underline{n} \Downarrow \V$ 
      for a closed value $\V$ if $f$ terminating and $\underline{n}$ a closed value.
  \end{enumerate}
    Consider G\"odel's \textbf{T}, simply typed lambda calculus with
    natural numbers and \emph{primitive recursion}:
    \begin{prooftree}
      \AXC{$\Gamma \vdash e_0 : \tau$}
      \AXC{$\Gamma \vdash \M : \nat$}
      \AXC{$\Gamma, x : \nat, y : \tau \vdash e_1 : \tau$}
      \insertBetweenHyps{\hskip .2em}
      \TIC{$\Gamma \vdash \mathtt{rec}(e_0; x.\,y.\, e_1; \M) : \tau$}
    \end{prooftree}
  \begin{enumerate}
      \conti
    \item Provide the one-step and big-step reductions for $\mathtt{rec}$. 
    \item Show that for every program $\M$ in \textbf{T}, there is a closed
      value $\V$ with $\M \Downarrow \V$. This property is called \emph{totality}.
      \emph{Hint.} Use the structural induction principle on the typing rules
      for \textbf{T}.
  \end{enumerate}
\end{frame}
\subsection*{Reference}
\begin{frame}<0>
  \emph{Denotational Semantics} and this lecture are based on the following 
  two books:
  \begin{enumerate}
    \item
      \href{http://www.mathematik.tu-darmstadt.de/~streicher/MGFP/MGFP.pdf.gz}{Thomas Streicher, \emph{Domain-Theoretic Foundations of Functional
      Programming}, World Scientific, 2006}
    \item \href{http://www.cs.cmu.edu/~rwh/plbook/book.pdf}{Robert Harper, \emph{Practical Foundations for Programming
        Languages}, Cambridge University Press, 2012}
  \end{enumerate}
  Their preprints are available on the Internet.
\end{frame}

\end{document}
